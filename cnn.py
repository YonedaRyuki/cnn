# -*- coding: utf-8 -*-
"""cnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1COKEzKayCq1KRIADeHcVxd7CzMTcIaI3
"""

from torchvision.datasets import CIFAR10
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
import numpy as np
import matplotlib.pyplot as plt

cifar10_data = CIFAR10(root = './data',
                       train = False,download = True,
                       transform = transforms.ToTensor())
cifar10_classes = np.array(['airplane','automobile','bird','cat','deer',
                            'dog','frog','horse','ship','truck'])
print('データの数',len(cifar10_data))

n_images = 25
cifar10_loader = DataLoader(cifar10_data,shuffle=True,batch_size=n_images)
dataiter = iter(cifar10_loader)
images,labels = dataiter.next()

plt.figure(figsize =(10,10))
for i in range(n_images):
  plt.subplot(5,5,i+1)
  plt.imshow(np.transpose(images[i],(1,2,0)))
  label = cifar10_classes[labels[i]]
  plt.title(label)
  plt.tick_params(labelbottom=False, labelleft=False, bottom = False, left = False)
plt.show()

transform = transforms.Compose([transforms.RandomAffine([-30,30],scale =(0.8,1.2)),
                                transforms.ToTensor()])
cifar10_data = CIFAR10(root = './data',
                       train = False,download = True,
                       transform = transform)
cifar10_classes = cifar10_classes = np.array(["airplane", "automobile", "bird", "cat", "deer",
                            "dog", "frog", "horse", "ship", "truck"])
print('データの数',len(cifar10_data))

n_images = 25
cifar10_loader = DataLoader(cifar10_data,batch_size=n_images,shuffle=True)
dataiter = iter(cifar10_loader)
images,labels = dataiter.next()

plt.figure(figsize=(10,10))
for i in range(n_images):
  plt.subplot(5,5,i+1)
  plt.imshow(np.transpose(images[i],(1,2,0)))
  label = cifar10_classes[labels[i]]
  plt.title(label)
  plt.tick_params(labelbottom =False,labelleft = False,bottom = False,left = False)
plt.show()

from torchvision.datasets import CIFAR10
import torchvision.transforms as transforms
from torch.utils.data import DataLoader

affine = transforms.RandomAffine([-15,15],scale=(0.8,1.2))
flip = transforms.RandomHorizontalFlip(p=0.5)
normalize = transforms.Normalize((0.0,0.0,0.0),(1.0,1.0,1.0))
to_tensor = transforms.ToTensor()

transform_train = transforms.Compose([affine,flip,to_tensor,normalize])
transform_test = transforms.Compose([to_tensor,normalize])

cifar10_train = CIFAR10(root='./data',
                        train = True,download = True,
                        transform = transform_train)
cifar10_test = CIFAR10(root = './data',
                       train = False,download=True,
                       transform = transform_test)
batch_size = 64
train_loader = DataLoader(cifar10_train,batch_size=batch_size,shuffle=True)
test_loader = DataLoader(cifar10_test,batch_size = len(cifar10_test),shuffle=False)

import torch.nn as nn
import torch.nn.functional as F

class Net(nn.Module):
  def __init__(self):
    super().__init__()
    self.conv1 = nn.Conv2d(3,6,5)
    self.pool = nn.MaxPool2d(2,2)
    self.conv2 = nn.Conv2d(6,16,5)
    self.fc1 = nn.Linear(16*5*5,256)
    self.dropout = nn.Dropout(p=0.5)
    self.fc2 = nn.Linear(256,10)
  
  def forward(self,x):
    x = self.pool(F.relu(self.conv1(x)))
    x = self.pool(F.relu(self.conv2(x)))
    x = x.view(-1,16*5*5)
    x = F.relu(self.fc1(x))
    x = self.dropout(x)
    x = self.fc2
    return x
net = Net()
net.cuda()
print(net)

import torch.nn as nn
import torch.nn.functional as F

class Net(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(3, 6, 5)  # 畳み込み層:(入力チャンネル数, フィルタ数、フィルタサイズ)
        self.pool = nn.MaxPool2d(2, 2)  # プーリング層:（領域のサイズ, ストライド）
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.fc1 = nn.Linear(16*5*5, 256)  # 全結合層
        self.dropout = nn.Dropout(p=0.5)  # ドロップアウト:(p=ドロップアウト率)
        self.fc2 = nn.Linear(256, 10)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16*5*5)
        x = F.relu(self.fc1(x))
        x = self.dropout(x)
        x = self.fc2(x)
        return x

net = Net()
net.cuda()  # GPU対応
print(net)

from torch import optim
loss_func =  nn.CrossEntropyLoss()
optimizer = optim.Adam(net.parameters())

record_loss_train = []
record_loss_test = []

x_test,t_test = iter(test_loader).next()
x_test,t_test =x_test.cuda(),t_test.cuda()
for i in range(20):
  net.train()
  loss_train = 0 
  for j,(x,t) in enumerate(train_loader):
    x,t = x.cuda(),t.cuda()
    y = net(x)
    loss = loss_func(y, t)
    loss_train += loss.item()
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
  loss_train = loss_train/j+1
  record_loss_train.append(loss_train)

  net.eval()
  y_test = net(x_test)
  loss_test = loss_func(y_test,t_test).item()
  record_loss_test.append(loss_test)

  if  i%1 == 0:
    print('Epoch:', i, 'Loss_Train:', loss_train,'Loss_Test:',loss_test)

import matplotlib.pyplot as plt

plt.plot(range(len(record_loss_train)),record_loss_train,label = 'Train')
plt.plot(range(len(record_loss_test)),record_loss_test,label='Test')
plt.legend()

plt.xlabel('Epochs')
plt.ylabel('Error')
plt.show()

correct = 0
total = 0
net.eval()
for i,(x,t) in enumerate(test_loader):
  x,t = x.cuda(),t.cuda()
  y = net(x)
  correct += (y.argmax(1) == t).sum().item()
  total += len(x)
print('正解率:',str(correct/total*100)+'%')

import numpy as np
cifar10_classes = cifar10_classes = np.array(["airplane", "automobile", "bird", "cat", "deer",
                            "dog", "frog", "horse", "ship", "truck"])
cifar10_loader = DataLoader(cifar10_test,batch_size=1,shuffle = True)
dataiter = iter(cifar10_loader)
images,labels = dataiter.next()

plt.imshow(np.transpose(images[0],(1,2,0)))
plt.tick_params(labelbottom = False, labelleft= False,bottom = False,left=False)
plt.show()

net.eval()
x,t = images.cuda(),labels.cuda()
y = net(x)
print('正解:',cifar10_classes[labels[0]],
      '予測結果:',cifar10_classes[y.argmax().item()])